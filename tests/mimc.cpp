#include <iostream>
#include <vector>
#include <gtest/gtest.h>

#include "../include/hash/mimc.hpp"

// This is set to match the rust implementation here: https://github.com/Zklib/libra-gkr/blob/mpi/src/mimc.rs
// The target is generated by the following rust code:
// #[cfg(test)]
// mod tests {
//     use num_bigint::BigUint;
//     use tiny_keccak::Keccak;
//     use ark_ff::fields::{Field, PrimeField, Fp64, MontBackend, MontConfig};

//     #[test]
//     fn mimc_on_small_prime_field() {
//         #[derive(MontConfig)]
//         #[modulus = "127"]
//         #[generator = "3"]
//         pub struct FqConfig;
//         pub type F = Fp64<MontBackend<FqConfig, 1>>;

//         const SEED: &str = "seed";
//         const N_ROUNDS: u32 = 110;
//         fn get_constants(seed: &str, n_rounds: i64) -> Vec<F> {
//             let mut cts: Vec<F> = Vec::new();

//             let mut keccak = Keccak::new_keccak256();
//             let mut h = [0u8; 32];
//             keccak.update(seed.as_bytes());
//             keccak.finalize(&mut h);

//             for _ in 0..n_rounds {
//                 let mut keccak = Keccak::new_keccak256();
//                 keccak.update(&h);
//                 keccak.finalize(&mut h);
//                 cts.push(F::from_be_bytes_mod_order(&h));
//             }
//             cts
//         }

//         let cts = get_constants(SEED, N_ROUNDS.into());
//         for ct in &cts {
//             print!("{:?}, ", Into::<BigUint>::into(*ct));
//         }
//         println!();

//         fn mimc5_hash(h: &F, x_in: &F, cts: &Vec<F>) -> F {
//             let mut x = *x_in;

//             fn pow5(x: F) -> F {
//                 let x2 = x * x;
//                 let x4 = x2 * x2;
//                 x4 * x
//             }

//             for i in 0..110 as usize {
//                 x = pow5(x + h + cts[i]);
//             }
//             x + h
//         }

//         fn hash(arr: Vec<F>, cts: &Vec<F>) -> F {
//             let mut h: F = F::from(0);
//             for a in &arr {
//                 let r = mimc5_hash(&h, a, cts);
//                 h += r + a;
//             }
//             h
//         }

//         let input = [F::from(13), F::from(27), F::from(888)];
//         let hash_result = hash(input.to_vec(), &cts);
//         println!("Hash result: {:?}", Into::<BigUint>::into(hash_result));
//     }
// }

TEST(MIMC_TESTS, MIMC_ON_SMALL_PRIME_FIELD)
{
    using F = gkr::small_prime_field::SmallPrimeField<127>;
    auto hasher = gkr::mimc::MIMC<F>();

    // Init correct
    EXPECT_EQ(hasher.constants.size(), 110);
    const unsigned target[110] = {19, 55, 51, 71, 108, 5, 43, 57, 35, 28, 54, 33, 5, 14, 57, 106, 8, 120, 114, 45, 110, 91, 108, 117, 109, 18, 81, 33, 122, 97, 34, 18, 45, 11, 86, 52, 58, 38, 37, 74, 74, 22, 83, 96, 57, 45, 75, 25, 122, 18, 21, 94, 110, 48, 66, 32, 36, 98, 59, 126, 13, 59, 26, 94, 84, 37, 67, 2, 9, 71, 102, 30, 95, 41, 74, 23, 26, 104, 93, 13, 91, 78, 49, 114, 4, 2, 79, 73, 7, 4, 2, 46, 66, 62, 21, 28, 0, 68, 55, 27, 8, 95, 62, 107, 21, 104, 22, 116, 2, 84};
    bool all_equal = true;
    for (uint i = 0; i < 110; i++)
    {
        all_equal &= hasher.constants[i] == F(target[i]);
    }
    EXPECT_TRUE(all_equal);

    // Simple hash correct
    std::vector<F> input = {F(13), F(27), F(888)};
    F hash = hasher.hash(input);
    EXPECT_EQ(hash, F(118));
}
